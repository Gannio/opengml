print("// This code was auto-generated by etc/meta/generate-fn-external-call-def.py")
print("// Hand-editing is not recommended.")
print("")

# definition
print("#define DEFN_external_call(calltype, fntype) \\")
print("void external_call_dispatch##calltype(VO out, std::string sig, fntype fn, byte argc, const Variable* argv) \\")
print("{ \\")

# generate if-else tree
def print_(str, indents):
    print("    " * indents + str + " \\")

def pretty_signature(sig, trail=False):
    dots = "..." if trail else ""
    if len(sig) == 0:
        return "?<-(" + dots + ")"
    if not trail and len(sig) == 1:
        return sig[0] + "<-()"
    return sig[0] + "<-(" + sig[1:] + dots + ")"

def print_leaf(sig, depth):
    print_("/* signature: " + pretty_signature(sig) + " */", depth)
    argtypes = ""
    first = True
    for c in sig[1:]:
        if not first:
            argtypes += ", "
        if c == 'r':
            argtypes += "real_t"
        else:
            argtypes += "const char*"
        first = False
    closestr = ""
    if (len(sig) == 1):
        closestr = ");"
    if (sig[0] == "r"):
        print_("out = ((real_t (calltype *)(" + argtypes +"))(fn))(" + closestr, depth)
    else:
        print_("out = ((const char* (calltype *)(" + argtypes + "))(fn))(" + closestr, depth)
    i = 0
    for c in sig[1:]:
        comma = ""
        if (i < len(sig) - 2):
            comma = ","
        if (c == "r"):
            print_("argv[" + str(i) + "].castCoerce<real_t>()" + comma, depth + 1)
        else:
            print_("argv[" + str(i) + "].castCoerce<std::string>().c_str()" + comma, depth + 1)
        i += 1

    if closestr == "":
        print_(");", depth)
    print_("return;", depth)

K_MAX = 15
K_MAX_MIX = 5

def print_tree(pre, depth=0, purer=True):
    print_("if (sig.length() == " + str(len(pre) + 1) + ")", depth + 1)
    print_("{", depth + 1)
    print_("if (sig.at(" + str(len(pre)) + ") == 'r')", depth + 2)
    print_("{", depth + 2)
    print_leaf(pre + 'r', depth + 3)
    print_("}", depth + 2)
    if len(pre) < K_MAX_MIX:
        print_("else", depth + 2)
        print_("{", depth + 2)
        print_leaf(pre + 's', depth + 3)
        print_("}", depth + 2)
    print_("}", depth + 1)
    if (len(pre) < K_MAX and purer) or len(pre) < K_MAX_MIX:
        print_("else if (sig.length() >= " + str(len(pre) + 1) + ")", depth + 1)
        print_("{", depth + 1)
        print_("/* signature: " + pretty_signature(pre, True) + " */", depth + 2)
        print_("if (sig.at(" + str(len(pre)) + ") == 'r')", depth + 2)
        print_("{", depth + 2)
        print_("/* signature: " + pretty_signature(pre + 'r', True) + " */", depth + 3)
        print_tree(pre + "r", depth + 2, purer)
        print_("}", depth + 2)
        if (len(pre) < K_MAX_MIX):
            print_("else", depth + 2)
            print_("{", depth + 2)
            print_("/* signature: " + pretty_signature(pre + 's', True) + " */", depth + 3)
            print_tree(pre + "s", depth + 2, False if len(pre) > 1 else purer)
            print_("}", depth + 2)
        print_("}", depth + 1)


print_tree("")
# the end
print("     \\")
print("    throw MiscError(\"Invalid call signature for external call: \" + sig); \\")
print("}")
